<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>go-i2p/common</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <nav class="nav-sidebar">
    <div class="repo-info">
      <h2>
        <a href="index.html">go-i2p/common</a>
      </h2>
      <div class="repo-meta">
        üìù 255 commits
         ‚Ä¢ üìú MIT License
      </div>
    </div>
    
    <ul class="nav-links">
      <li><a href="index.html" class="active">Repository Overview</a></li>
      
      
        <div class="nav-section-title">Documentation:</div>
        
          <li><a href="docs/common.html">Common Structures Specification</a></li>
        
          <li><a href="docs/RELEASE_NOTES.html">RELEASE NOTES</a></li>
        
          <li><a href="docs/template.html">Template</a></li>
        
      
    </ul>
    
    <div class="nav-footer">
      <a href="https://github.com/go-i2p/common" target="_blank">View on GitHub</a>
    </div>
  </nav>
  
  <div class="main-content">
    <header class="repo-header">
      <h1>go-i2p/common</h1>
      <div class="repo-description">A comprehensive Go library implementing I2P (Invisible Internet Project) network protocol common data structures and utilities. This library provid...</div>
      
      <div class="repo-stats">
        
        <div class="repo-stat">
          <span>üìù</span> <span>255 commits</span>
        </div>
        
        
        <div class="repo-stat">
          <span>üìÖ</span> <span>Last updated: February 19, 2026</span>
        </div>
        
        
        <div class="repo-stat">
          <span>üìú</span> <span>MIT License</span>
        </div>
        
      </div>
    </header>
    
    <main>
      
      <section id="readme" class="repo-section">
        <h2>README</h2>
        <div class="readme-content">
          <h1 id="go-i2p-common">go-i2p/common</h1>

<p>A comprehensive Go library implementing I2P (Invisible Internet Project) network protocol common data structures and utilities. This library provides type-safe implementations of the I2P specification common structures, factored out from the main I2P router to enable reusable components for parsing, encoding, and manipulating I2P network data.</p>

<hr>

<h2 id="installation">Installation</h2>

<pre><code class="language-bash">go mod init your-project
go get github.com/go-i2p/common
</code></pre>

<hr>

<h2 id="usage">Usage</h2>

<h3 id="creating-key-certificates-new-simplified-api">Creating Key Certificates (New Simplified API)</h3>

<p>The library now provides simplified constructors for common key certificate types:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/key_certificate&quot;
)

func main() {
    // Modern Ed25519/X25519 key certificate (recommended)
    keyCert, err := key_certificate.NewEd25519X25519KeyCertificate()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    fmt.Printf(&quot;Signing type: %d\n&quot;, keyCert.SigningPublicKeyType())
    fmt.Printf(&quot;Crypto type: %d\n&quot;, keyCert.PublicKeyType())
    
    // Or create with custom key types
    keyCert, err = key_certificate.NewKeyCertificateWithTypes(
        key_certificate.KEYCERT_SIGN_ED25519,
        key_certificate.KEYCERT_CRYPTO_X25519,
    )
}
</code></pre>

<h3 id="getting-key-sizes-without-object-creation">Getting Key Sizes Without Object Creation</h3>

<p>Query key sizes for padding calculations without creating certificate objects:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/key_certificate&quot;
    &quot;github.com/go-i2p/common/keys_and_cert&quot;
)

func main() {
    // Get size information for key types
    sizes, err := key_certificate.GetKeySizes(
        key_certificate.KEYCERT_SIGN_ED25519,
        key_certificate.KEYCERT_CRYPTO_X25519,
    )
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    // Calculate padding size
    paddingSize := keys_and_cert.KEYS_AND_CERT_DATA_SIZE - 
        (sizes.CryptoPublicKeySize + sizes.SigningPublicKeySize)
    
    fmt.Printf(&quot;Signature size: %d bytes\n&quot;, sizes.SignatureSize)
    fmt.Printf(&quot;Signing public key size: %d bytes\n&quot;, sizes.SigningPublicKeySize)
    fmt.Printf(&quot;Crypto public key size: %d bytes\n&quot;, sizes.CryptoPublicKeySize)
    fmt.Printf(&quot;Required padding: %d bytes\n&quot;, paddingSize)
}
</code></pre>

<h3 id="using-the-certificate-builder-pattern">Using the Certificate Builder Pattern</h3>

<p>For complex certificate construction scenarios:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/certificate&quot;
)

func main() {
    // Build a key certificate using fluent interface
    cert, err := certificate.NewCertificateBuilder().
        WithKeyTypes(certificate.KEYCERT_SIGN_ED25519, certificate.KEYCERT_CRYPTO_X25519).
        Build()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    // Or build a certificate with custom payload
    customPayload := []byte{0x01, 0x02, 0x03, 0x04}
    cert, err = certificate.NewCertificateBuilder().
        WithType(certificate.CERT_SIGNED).
        WithPayload(customPayload).
        Build()
}
</code></pre>

<h3 id="simple-integer-encoding">Simple Integer Encoding</h3>

<p>Use the new encoding utilities for cleaner binary encoding:</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/data&quot;
)

func main() {
    // Encode integers without error handling (for valid values)
    signingType := data.EncodeUint16(7)  // Ed25519
    cryptoType := data.EncodeUint16(4)   // X25519
    
    fmt.Printf(&quot;Signing type bytes: %v\n&quot;, signingType[:])
    fmt.Printf(&quot;Crypto type bytes: %v\n&quot;, cryptoType[:])
    
    // Decode back to integers
    sigValue := data.DecodeUint16(signingType)
    cryptoValue := data.DecodeUint16(cryptoType)
    
    fmt.Printf(&quot;Decoded signing: %d, crypto: %d\n&quot;, sigValue, cryptoValue)
    
    // For variable-length encoding with validation
    bytes, err := data.EncodeIntN(1234, 2)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    fmt.Printf(&quot;Encoded bytes: %v\n&quot;, bytes)
}
</code></pre>

<h3 id="basic-certificate-parsing">Basic Certificate Parsing</h3>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/certificate&quot;
)

func main() {
    // Parse I2P certificate from binary data
    data := []byte{0x00, 0x00, 0x02, 0xff, 0xff}
    cert, remainder, err := certificate.ReadCertificate(data)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    fmt.Printf(&quot;Certificate type: %d\n&quot;, cert.Type())
    fmt.Printf(&quot;Certificate length: %d\n&quot;, cert.Length())
    fmt.Printf(&quot;Remaining bytes: %d\n&quot;, len(remainder))
}
</code></pre>

<h3 id="working-with-destinations">Working with Destinations</h3>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/destination&quot;
)

func main() {
    // Read destination from binary data
    data := []byte{/* destination bytes */}
    dest, remainder, err := destination.ReadDestination(data)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    // Generate I2P addresses
    base32Address := dest.Base32Address()
    base64Address := dest.Base64()
    
    fmt.Printf(&quot;Base32 address: %s\n&quot;, base32Address)
    fmt.Printf(&quot;Base64 address: %s\n&quot;, base64Address)
}
</code></pre>

<h3 id="parsing-router-information">Parsing Router Information</h3>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/router_info&quot;
)

func main() {
    // Read router info from binary data
    data := []byte{/* router info bytes */}
    routerInfo, remainder, err := router_info.ReadRouterInfo(data)
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    // Access router information
    identity := routerInfo.RouterIdentity()
    addresses := routerInfo.RouterAddresses()
    capabilities := routerInfo.RouterCapabilities()
    
    fmt.Printf(&quot;Router identity: %v\n&quot;, identity)
    fmt.Printf(&quot;Router addresses: %d\n&quot;, len(addresses))
    fmt.Printf(&quot;Router capabilities: %s\n&quot;, capabilities)
}
</code></pre>

<h3 id="working-with-i2p-strings">Working with I2P Strings</h3>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/go-i2p/common/data&quot;
)

func main() {
    // Parse I2P string from binary data
    stringData := []byte{0x05, 'h', 'e', 'l', 'l', 'o'}
    i2pString := data.I2PString(stringData)
    
    length, err := i2pString.Length()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    content, err := i2pString.Data()
    if err != nil {
        fmt.Printf(&quot;Error: %v\n&quot;, err)
        return
    }
    
    fmt.Printf(&quot;String length: %d\n&quot;, length)
    fmt.Printf(&quot;String content: %s\n&quot;, content)
}
</code></pre>

<hr>

<h2 id="requirements">Requirements</h2>

<ul>
<li><strong>Go Version</strong>: 1.24.2 or later</li>
<li><strong>I2P Specification</strong>: 0.9.67 (June 2025)</li>
<li><strong>Dependencies</strong>:

<ul>
<li><code>github.com/go-i2p/go-i2p</code> - Core I2P library</li>
<li><code>github.com/go-i2p/logger</code> - Structured logging wrapper</li>
<li><code>github.com/samber/oops</code> - Enhanced error handling</li>
<li><code>github.com/sirupsen/logrus</code> - Logging framework</li>
<li><code>github.com/stretchr/testify</code> - Testing utilities</li>
</ul></li>
</ul>

<hr>

<h2 id="testing">Testing</h2>

<p>Run the comprehensive test suite:</p>

<pre><code class="language-bash"># Run all tests
make test

# Run specific component tests
go test ./certificate/...
go test ./destination/...
go test ./router_info/...

# Run fuzz tests
go test -fuzz=FuzzCertificate ./certificate/
</code></pre>

<hr>

<h2 id="license">License</h2>

<p>MIT License - see <a href="LICENSE" target="_blank">LICENSE</a> file for details.</p>

<p>Copyright &copy; 2025 I2P For Go</p>

        </div>
      </section>
      
      
      
      <section id="contributors" class="repo-section">
        <h2>Top Contributors</h2>
        <div class="contributors-list">
          
          <div class="contributor-item">
            <!-- Use first letter as avatar if no image available -->
            <div class="contributor-avatar">
              e
            </div>
            <div class="contributor-info">
              <div class="contributor-name">
                eyedeekay
              </div>
              <div class="contributor-commits">
                255 commits
              </div>
            </div>
          </div>
          
        </div>
        <a href="https://github.com/go-i2p/common/graphs/contributors" target="_blank">View all contributors on GitHub ‚Üí</a>
      </section>
      
    </main>
    
    <footer class="page-footer">
      <p>Generated on 2026-02-20 22:17:39 ‚Ä¢ <a href="https://github.com/go-i2p/common" target="_blank">View on GitHub</a></p>
    </footer>
  </div>
</body>
</html>