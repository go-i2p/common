// Package signature implements the I2P Signature common data structure
package signature

import (
	"fmt"

	"github.com/go-i2p/logger"
)

/*
[Signature]
Accurate for version 0.9.49

Description
This structure represents the signature of some data.

Contents
Signature type and length are inferred from the type of key used. The default type is
DSA_SHA1. As of release 0.9.12, other types may be supported, depending on context.
*/

// Signature is the represenation of an I2P Signature.
//
// https://geti2p.net/spec/common-structures#signature
type Signature struct {
	// sigType holds the signature algorithm type identifier
	// This corresponds to one of the SIGNATURE_TYPE_* constants and determines
	// both the cryptographic algorithm used and the expected signature length
	sigType int

	// data holds the raw signature bytes
	// The length is determined by the signature algorithm type and contains
	// the actual cryptographic signature generated by the signing process
	data []byte
}

// NewSignature creates a new *Signature from []byte using ReadSignature.
// Returns a pointer to Signature unlike ReadSignature.
func NewSignature(data []byte, sigType int) (signature *Signature, remainder []byte, err error) {
	log.WithField("input_length", len(data)).Debug("Creating new Signature")

	// Use ReadSignature to parse and validate the signature data
	// This ensures proper type validation and length checking before creation
	sig, remainder, err := ReadSignature(data, sigType)
	if err != nil {
		log.WithError(err).Error("Failed to read Signature")
		return nil, remainder, err
	}
	signature = &sig
	log.WithFields(logger.Fields{
		"signature_length": sig.Len(),
		"remainder_length": len(remainder),
	}).Debug("Successfully created new Signature")
	return
}

// NewSignatureFromBytes creates a Signature struct from raw bytes without type validation.
// This function is used when the signature type is known but validation is not needed.
// It directly constructs a Signature with the provided data and sigType without parsing or validation.
// Example usage: sig := NewSignatureFromBytes(rawData, SIGNATURE_TYPE_EDDSA_SHA512_ED25519)
func NewSignatureFromBytes(data []byte, sigType int) Signature {
	// Direct construction without validation for performance-critical scenarios
	// Caller is responsible for ensuring data integrity and proper type matching
	return Signature{
		sigType: sigType,
		data:    data,
	}
}

// Type returns the signature algorithm type identifier.
// The returned integer corresponds to one of the SIGNATURE_TYPE_* constants,
// indicating which cryptographic algorithm was used to generate this signature.
func (s Signature) Type() int {
	// Return the algorithm type identifier for cryptographic validation
	return s.sigType
}

// Bytes returns the raw signature data as a byte slice for compatibility.
// This method provides access to the underlying signature bytes without exposing
// the internal structure, enabling integration with external cryptographic libraries.
func (s Signature) Bytes() []byte {
	// Return signature data for use with cryptographic verification functions
	return s.data
}

// Len returns the length of the signature data in bytes.
// The length depends on the signature algorithm type and can be used for
// validation or memory allocation purposes.
func (s Signature) Len() int {
	// Calculate signature length for validation and buffer management
	return len(s.data)
}

// String returns a string representation of the signature type and length.
// Provides human-readable information about the signature for debugging and logging.
// Format: "Signature{type: X, length: Y}" where X is the algorithm type and Y is byte length.
func (s Signature) String() string {
	// Format signature information for debugging and diagnostic output
	return fmt.Sprintf("Signature{type: %d, length: %d}", s.sigType, len(s.data))
}
