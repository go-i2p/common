// Package signature implements the I2P Signature common data structure
package signature

import (
	"crypto/subtle"
	"fmt"

	"github.com/go-i2p/logger"
	"github.com/samber/oops"
)

/*
[Signature]
Accurate for version 0.9.67

Description
This structure represents the signature of some data.

Contents
Signature type and length are inferred from the type of key used. The default type is
DSA_SHA1. As of release 0.9.12, other types may be supported, depending on context.
*/

// Signature is the represenation of an I2P Signature.
//
// https://geti2p.net/spec/common-structures#signature
type Signature struct {
	// sigType holds the signature algorithm type identifier
	// This corresponds to one of the SIGNATURE_TYPE_* constants and determines
	// both the cryptographic algorithm used and the expected signature length
	sigType int

	// data holds the raw signature bytes
	// The length is determined by the signature algorithm type and contains
	// the actual cryptographic signature generated by the signing process
	data []byte
}

// NewSignature creates a new *Signature from []byte using ReadSignature.
// Returns a pointer to Signature unlike ReadSignature.
func NewSignature(data []byte, sigType int) (signature *Signature, remainder []byte, err error) {
	log.WithField("input_length", len(data)).Debug("Creating new Signature")

	// Use ReadSignature to parse and validate the signature data
	// This ensures proper type validation and length checking before creation
	sig, remainder, err := ReadSignature(data, sigType)
	if err != nil {
		log.WithError(err).Error("Failed to read Signature")
		return nil, remainder, err
	}
	signature = &sig
	log.WithFields(logger.Fields{
		"signature_length": sig.Len(),
		"remainder_length": len(remainder),
	}).Debug("Successfully created new Signature")
	return
}

// NewSignatureFromBytes creates a Signature struct from raw bytes with type and length validation.
// Returns an error if the sigType is out of the valid spec range (0-65535),
// the type is unsupported/reserved, or the data length does not match the
// expected signature size for the given type.
//
// Example usage:
//
//	sig, err := NewSignatureFromBytes(rawData, SIGNATURE_TYPE_EDDSA_SHA512_ED25519)
//	if err != nil { /* handle error */ }
func NewSignatureFromBytes(data []byte, sigType int) (Signature, error) {
	expectedLen, err := getSignatureLength(sigType)
	if err != nil {
		return Signature{}, err
	}
	if len(data) != expectedLen {
		return Signature{}, oops.Errorf(
			"signature data length %d does not match expected %d for type %d",
			len(data), expectedLen, sigType,
		)
	}
	sigData := make([]byte, len(data))
	copy(sigData, data)
	return Signature{
		sigType: sigType,
		data:    sigData,
	}, nil
}

// Type returns the signature algorithm type identifier.
// The returned integer corresponds to one of the SIGNATURE_TYPE_* constants,
// indicating which cryptographic algorithm was used to generate this signature.
func (s Signature) Type() int {
	// Return the algorithm type identifier for cryptographic validation
	return s.sigType
}

// Bytes returns the raw signature data as a byte slice for compatibility.
// This method provides access to the underlying signature bytes without exposing
// the internal structure, enabling integration with external cryptographic libraries.
func (s Signature) Bytes() []byte {
	// Return signature data for use with cryptographic verification functions
	return s.data
}

// Len returns the length of the signature data in bytes.
// The length depends on the signature algorithm type and can be used for
// validation or memory allocation purposes.
func (s Signature) Len() int {
	// Calculate signature length for validation and buffer management
	return len(s.data)
}

// Equal returns true if the other Signature has the same type and data.
// Both the signature algorithm type and raw bytes must match for equality.
// Uses constant-time comparison via crypto/subtle to prevent timing side-channels.
func (s Signature) Equal(other *Signature) bool {
	if other == nil {
		return false
	}
	if s.sigType != other.sigType {
		return false
	}
	if len(s.data) != len(other.data) {
		return false
	}
	return subtle.ConstantTimeCompare(s.data, other.data) == 1
}

// String returns a string representation of the signature type and length.
// Provides human-readable information about the signature for debugging and logging.
// Format: "Signature{type: X, length: Y}" where X is the algorithm type and Y is byte length.
func (s Signature) String() string {
	// Format signature information for debugging and diagnostic output
	return fmt.Sprintf("Signature{type: %d, length: %d}", s.sigType, len(s.data))
}
